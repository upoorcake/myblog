---
title: 线性回归
date: 2025-09-22 00:08:56
tags:
  - 机器学习
  - 线性回归
categories:
  - 机器学习 
  - 线性回归
cover: http://img.upoorcake.cn/upoorcake/006cn0osly1g5i0wlat9sj32tc240hdt.jpg
description:
---

# 线性回归

1. 单变量线性回归 (Linear Regression with One Variable)

    模型表示

    代价函数

    梯度下降

    梯度下降的直观理解

    梯度下降的线性回归

2. 多变量线性回归 (Linear Regression with Multiple Variables)

    多维特征

    多变量梯度下降

        梯度下降法实践1：特征缩放

            数据的标准化 (Normalization)

        梯度下降法实践2：学习率 (Learning Rate)

    特征和多项式回归

3. 正规方程 Normal Equations

    对比梯度下降和正规方程

        正规方程及不可逆性

4. Jupter Notebook编程练习

# 单变量线性回归

例： 预测住房价格

数据集：一直一个数据既包含某个城市的住房价格。每个样本包括房屋尺寸售价
问题：根据不同的房屋尺寸售出价格，预测如果1250平方尺的房屋售价
数据集：
房屋大小 (x)    价格 (y)

2104    460

1416    232

1534    315

852 178

... ...

我们用如下的符号来描述这个问题：

m： 代表训练集中样本的数量（下文也将用 m 表示训练样本数量）

x： 代表特征/输入变量

y： 代表目标变量/输出变量

(x, y)： 代表训练集中的一个样本

(x(i), y(i))：代表第 i 个观察样本

h：代表学习算法的解决方案或函数也称为假设（hypothesis）

这个监督学习的工作方式如下：

训练集 → 学习算法
	            ↓
房屋大小  →  h  → 预测价格

1. 把训练编辑输入到学习算法
2. 学习算法计算出函数h
3. 应用h，输入尺寸推算价格

只含有一个特征/输入变量 我们成为单变量线性回归问题
  
![image.png](http://img.upoorcake.cn/upoorcake/202509212212249.png)
下一步是如何确定参数θ0和θ1，在这个例子中 _θ1_ 是直线的斜率， _θ0_ 是在 _y_ 轴上的截距。
#### 代价函数
为衡量h的性能，回归任务中常见的方法是定义代价函数（Cost Function）：
1. 均方误差
	![image.png](http://img.upoorcake.cn/upoorcake/202509212215807.png)
2. 选取参数以最小化J，从而优化h

我们绘制一个等高线图，三个坐标分别为θ0 和 _θ1_、_J(θ0, θ1)_，可以看到三维空间中存在一个使得 _J(θ0, θ1)_ 最小的点：

![image.png](http://img.upoorcake.cn/upoorcake/202509212217787.png)

![image.png](http://img.upoorcake.cn/upoorcake/202509212218473.png)
根据上图，人工的方法很容易找到代价函数最小值对应的θ0和 θ1 ，但我们真正需要的是一种有效的算法，能够自动的找出这些使代价函数J取最小值的参数θ0和 θ1 。也就是我们下面要提到的**梯度下降**

#### 梯度下降

1. 梯度下降是一种用来求函数最小值的算法
2. 思想：开始时随机选择一个参数组合 _(θ0, θ1, ..., θn)_，计算代价函数；然后寻找下一个能让函数值下降最多的参数组合。持续这么做知道找到一个局部最小值，因为我们没有尝试完所有的参数组合。所以不能确定我们得到的局部最小值是否便是全局最小值，选择不同的参数组合可能会找到不同的局部最小值

![image.png](http://img.upoorcake.cn/upoorcake/202509212224181.png)

3. 为了理解梯度下降，可以想象一下你正站立在山的一点上（上图中的红色起始点），并且希望用最短的时间下山。在梯度下降算法中，要做的就是旋转360度，看看周围，并问自己要在某个方向上，用小碎步尽快下山。这些小碎步需要朝什么方向？如果我们站在山坡上的这一点，看一下周围，你会发现最佳的下山方向，按照自己的判断迈出一步；重复上面的步骤，从新的位置，环顾四周，并决定从什么方向将会最快下山，然后又迈进了一小步，并依此类推，直到你接近局部最低点的位置。
4. 批量梯度下降（batch gradient descent）算法可以抽象为公式：

	![image.png](http://img.upoorcake.cn/upoorcake/202509212225787.png)
5. 其中 _α_ 是**学习率**（Learning rate），它决定了沿着能让代价函数下降程度最大的方向向下迈出的步子有多大；在批量梯度下降中，每一次都同时让所有的参数减去学习速率乘以代价函数的导数。

上面的公式展开如下：

![image.png](http://img.upoorcake.cn/upoorcake/202509212227182.png)
**重点**：更新上述式子需要同时更新一组参数 _(θ0, θ1, ..., θn)_ ，之后再开始下一轮迭代。 这里先不解释为什么需要同时更新。但请记住，同时更新是梯度下降中常用方法。之后会讲到，同步更新也是更自然的实现方法。人们谈到梯度下降时，意思就是同步更新。

#### 梯度下降的直观理解

考虑上图中关于梯度下降的公式，其中求导，是取红点的切线，就是下图中红色的直线，其与函数相切于红色的点。红色直线的斜率，正好是下图红色三角形的高度除以这个水平长度，这条线有一个正斜率，也就是说它有正导数，因此，为了得到更新的 _J_，_θ1_ 更新后等于 _θ1_ 减去一个正数乘以 _α_。
![image.png](http://img.upoorcake.cn/upoorcake/202509212252561.png)

_α_ 的取值有怎么的影响？

- 如果 _α_ 太小，即学习速率太小，结果是红点一点点挪动，努力去接近最低点，需要很多步才能到达最低点。同样会需要很多步才能到达全局最低点。（如下图-左图）
- 如果 _α_ 太大，梯度下降法可能会越过最低点，甚至可能无法收敛，下一次迭代又移动了一大步，一次次越过最低点，直到你发现实际上离最低点越来越远，所以如果 _α_ 太大，它会导致无法收敛，甚至发散。（如下图-右图）

![image.png](http://img.upoorcake.cn/upoorcake/202509212252309.png)

现在，还有一个问题，需要思考，如果我们预先把 _θ1_ 放在一个局部的最低点，下一步梯度下降法会怎样工作？

假设你将 _θ1_ 初始化在局部最低点，它已经在一个局部的最优处或局部最低点。结果是局部最优点的导数将等于零，因为它是那条切线的斜率。使得 _θ1_ 不再改变，也就是新的 _θ1_ 等于原来的 _θ1_ ，因此，如果参数已经处于局部最低点，那么梯度下降法更新其实什么都没做，它不会改变参数的值。这也解释了为什么即使学习速率 _α_ 保持不变时，梯度下降也可以收敛到局部最低点。

我们再来看下代价函数 _J(θ)_ ，如下图

![image.png](http://img.upoorcake.cn/upoorcake/202509212253206.png)
随着接近最低点，导数越来越接近零，所以，梯度下降一步后，新的导数会变小一点点。再梯度下降一步，在这个绿点，会用一个稍微跟刚才在那个品红点时比，再小一点的一步，到了新的红色点，更接近全局最低点了，因此这点的导数会比在绿点时更小。所以，再进行一步梯度下降时，导数项是更小的， _θ1_ 更新的幅度就会更小。所以随着梯度下降法的运行，移动的幅度会自动变得越来越小，直到最终移动幅度非常小，这时已经收敛到局部极小值。

总结一下：

- 在梯度下降法中，当接近局部最低点时，梯度下降法会自动采取更小的幅度，这是因为当接近局部最低点时，导数值会自动变得越来越小，梯度下降将自动采取较小的幅度。所以实际上没有必要再另外减小 _α_。
- 你可以用它来最小化任何代价函数 _J(θ)_ ，不只是线性回归中的代价函数 _J(θ)_。
- 
![image.png](http://img.upoorcake.cn/upoorcake/202509212255971.png)


上述算法有时也称为 **批量梯度下降（Batch Gradient Descent）**。**“批量”是**指在梯度下降的每一步中，我们都用到了所有的训练样本。

- 在梯度下降，计算微分求导项时，需要求和运算，所以，在每一个单独的梯度下降中，最终都要计算这样一个东西，这个项需要对所有 _m_ 个训练样本求和。
- 批量梯度下降法这个名字说明需要考虑所有这一"批"训练样本。事实上，也有其他类型的梯度下降法，不是"批量"型的，不考虑整个的训练集，每次只关注训练集中的一些小的子集。后续会介绍。

此外，也许你知道有一种计算代价函数最小值的数值解法，不需要梯度下降这种迭代算法。在后面我们也会谈到这个方法，可以在不需要多步梯度下降的情况下，解出代价函数的最小值，这中方法称为**正规方程(normal equations)**。实际上在数据量较大的情况下，梯度下降法比正规方程要更适用一些。

# 多变量线性回归 (Linear Regression with Multiple Variables)

## 多维特征

在之前的房价预测问题里，只考虑到房屋尺寸一个特征，这里我们考虑多个特征的问题。比如在房价预测问题中，引入房间数、楼层、年限等。

下表是一个示例数据：

|房屋大小|房间数|楼层|年限|价格 (_y_)|
|:-:|:-:|:-:|:-:|:-:|
|2104|5|1|45|460|
|1416|3|2|40|232|
|1534|3|2|30|315|
|852|2|1|36|178|
|...|...|...|...|...|

介绍更多的问题描述符号：

- _n_：特征的数量
- _x(i)_：第i个训练样本。如果样本用矩阵表示，那它对应就是矩阵的第 _i_ 行，也是一个向量。比如 _x(2) = [1416; 3; 2; 40; 232]_。
- _xj(i)_：训练样本中的第 _i_ 个hang本中的第 _j_ 个特征，也就是矩阵里的 _i_ 行的 _j_ 列。

多变量的假设 h 表示为：

![image.png](http://img.upoorcake.cn/upoorcake/202509212259519.png)


上述公式中有 _n+1_ 个参数和 _n_ 个变量，为了简化公式，引入 _x0 = 1_，则上式写作：

![image.png](http://img.upoorcake.cn/upoorcake/202509212259924.png)


其中，_T_ 代表矩阵转置

在多变量线性回归中，我们也构建一个代价函数，则这个代价函数是所有建模误差的平方和，即：

![image.png](http://img.upoorcake.cn/upoorcake/202509212259588.png)
计算代价函数的Python代码如下：

```python
def compute_cost(X, y, theta):
    inner = np.power(((X * theta.T) - y), 2)
    return np.sum(inner) / (2 * len(X))
```

### 多变量梯度下降


多变量梯度下降的目标和单变量线性回归问题中一样，要找出使得代价函数最小的一系列参数。多变量线性回归的批量梯度下降算法为：
![image.png](http://img.upoorcake.cn/upoorcake/202509212302655.png)
求导后得到：
![image.png](http://img.upoorcake.cn/upoorcake/202509212302335.png)
可以看出，有 _n_ 个特诊的梯度下降算法和算法 单特征的梯度下降算法的区别是 _θ_ 变量的个数及在每一步更新 _θ_ 变量的个数。

#### 梯度下降法实践1：特征缩放

**在面对多维特征问题时，要保证这些特征都具有相近的尺度，将使梯度下降算法更快地收敛。**

以房价问题为例，假如有两个特征，房屋尺寸和房间数量。尺寸值为 0-2000平方英尺，房间数量取值0-5，以两个参数分别为横纵坐标，绘制代价函数的等高线图能，看出图像会显得很扁，梯度下降算法需要非常多次的迭代才能收敛。如下图：

![image.png](http://img.upoorcake.cn/upoorcake/202509212303845.png)
解决的方法是尝试将所有特征的尺度都尽量缩放到-1到1之间。如图右图：

![image.png](http://img.upoorcake.cn/upoorcake/202509212303312.png)
##### 数据的标准化 (Normalization)

对于X数据的标准化公式：![image.png](http://img.upoorcake.cn/upoorcake/202509212305610.png)

其中 _μn_ 是平均值，_sn_ 是标准差。Python示例代码如下：

```python
import numpy as np
X = np.random.rand(5, 2)

mu = np.mean(X, axis=0)
std = np.std(X, axis=0)
X = X - mu
X = X / std
```

#### 梯度下降法实践2：学习率 (Learning Rate)

梯度下降算法收敛所需要的迭代次数根据模型的不同而不同，虽不能提前预知，但可以画出迭代次数和代价函数 _J_ 的图表来观测算法在何时趋于收敛。如下图所示，可以看到 _J_ 是随着迭代次数增加而不断的减小。当迭代次数达到300之后， _J_ 降低的趋势已经非常小了，说明已经收敛。

![image.png](http://img.upoorcake.cn/upoorcake/202509212320859.png)

也有一些自动测试是否收敛的方法，例如将代价函数的变化值与某个阀值（例如0.001）进行比较，如果比阈值小，就认为已经收敛。但通常看上面这样的图表更好。

梯度下降算法的迭代受到学习率 _α_ 影响：

- 如果学习率 _α_ 过小，则达到收敛所需的迭代次数会非常高；
- 如果学习率 _α_ 过大，每次迭代可能不会减小代价函数，可能会越过局部最小值导致无法收敛。

通常可以考虑尝试些学习率： _α = 0.01，0.03，0.1，0.3，1，3，10_

最后，大的原则是，**有效的 _α_ 是可以让 _J_ 随着迭代不断变小。但太小的 _α_ 会导致收敛的很慢**。

### 特征和多项式回归

仍然是以房价预测为例：

按照此前的线性回归模型可得： _hθ(x) = θ0 + θ1 × frontage + θ2 × depth_

定义：

- _x1 = frontage_（临街宽度）
- _x2 = depth_（纵向深度）
- _x = frontage*depth = area_（面积）

则：_hθ(x) = θ0 + θ1x_。

线性回归并不适用于所有数据，有时我们需要曲线来适应我们的数据，比如一个二次方模型：_hθ(x) = θ0 + θ1x1 + θ2x2_ 或者三次方模型： _hθ(x) = θ0 + θ1x1 + θ2x2 + θ3x3_。如下图所示：

通常我们需要先观察数据然后再决定模型的类型。此外，可以令 _x2 = x2_，_x3 = x3_，从而将多项式回归转换为线性回归。

### 正规方程 Normal Equations

我们都在使用梯度下降算法，但是对于某些线性回归问题，正规方程方法是更好的解决方案。如：

![image.png](http://img.upoorcake.cn/upoorcake/202509212322371.png)
正规方程是通过求解下面的方程来找出使得代价函数最小的参数的：![image.png](http://img.upoorcake.cn/upoorcake/202509212323296.png)
。 假设我们的训练集特征矩阵为 _X_（包含了 _x0 = 1_）并且我们的训练集结果为向量 _y_，则利用正规方程解出向量：

![image.png](http://img.upoorcake.cn/upoorcake/202509212329198.png)
推导如下：
![image.png](http://img.upoorcake.cn/upoorcake/202509212329115.png)
举个例子：

![image.png](http://img.upoorcake.cn/upoorcake/202509212329945.png)
运用正规方程方法求解参数：

![image.png](http://img.upoorcake.cn/upoorcake/202509212330815.png)
上面的正规方程用Python的实现如下：

```python
import numpy as np

def normal_equation(X, y):
	theta = np.linalg.pinv(X.T @ X) @ X.T @ y
```

**注意**：对于不可逆的矩阵 _X_（通常因为特征之间不独立，如同时包含英尺为单位的尺寸和米为单位的尺寸两个特征，也有可能是特征数量大于训练集的数量），正规方程方法是不能用。

### 对比梯度下降和正规方程

| 梯度下降             | 正规方程                                                                            |
| ---------------- | ------------------------------------------------------------------------------- |
| 需要选择学习率 _α_      | 不需要                                                                             |
| 需要多次迭代           | 一次运算得出                                                                          |
| 当特征数量 _n_ 很大时也适用 | 需要计算 _(XTX)-1_ 如果特征数量n较大则运算代价大，因为矩阵逆的计算时间复杂度为 _O(n3)_，通常来说当 _n_ 小于10000 时还是可以接受 |
| 适用于各种类型的模型       | 只适用于线性模型，不适合逻辑回归模型等其他模型                                                         |

#### 正规方程及不可逆性

我们称那些不可逆矩阵为奇异或退化矩阵。有两种情况可能导致矩阵的不可逆：

- 在 _m_ 小于或等于 _n_
    - 我们会使用一种叫做正则化（Regularization）的线性代数方法删除某些特征
- 特征之间线性相关：
    - 可以删除这两个重复特征里的其中一个


 



